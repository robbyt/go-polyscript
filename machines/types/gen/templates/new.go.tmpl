//go:generate go run ./types/gen/typeGen.go
// Code generated by go generate; DO NOT EDIT.

package machines

import (
	"fmt"
	"log/slog"

	"github.com/robbyt/go-polyscript/engine"
	"github.com/robbyt/go-polyscript/execution/script"
{{- range .Types}}
	{{.Value}}Machine "github.com/robbyt/go-polyscript/machines/{{.Value}}"
{{- end}}
	
	machineTypes "github.com/robbyt/go-polyscript/machines/types"
)

// NewEvaluator creates a new VM with the given CPU type and globals.
// This will load a script from a ExecutableUnit object into the VM, and can be run immediately.
// The ExecutableUnit contains a DataProvider that provides runtime data for evaluation.
func NewEvaluator(handler slog.Handler, ver *script.ExecutableUnit) (engine.Evaluator, error) {
	if ver == nil {
		return nil, fmt.Errorf("version is nil")
	}

	switch ver.GetMachineType() {
	{{- range .Types}}
	case machineTypes.{{.Name}}:
		// {{.Description}}
		return {{.Value}}Machine.NewBytecodeEvaluator(handler, ver), nil
	{{- end}}
	default:
		return nil, fmt.Errorf("%w: %s", machineTypes.ErrInvalidMachineType, ver.GetMachineType())
	}
}

// NewCompiler creates a compiler based on the option types.
// It determines which compiler to use by checking the types of the provided options.
func NewCompiler(opts ...any) (script.Compiler, error) {
	if len(opts) == 0 {
		return nil, fmt.Errorf("no options provided")
	}

	{{range .Types}}
	// Check for {{.Name}} options
	{
		var {{.Value}}Opts []{{.Value}}Machine.Option
		allMatch := true

		for _, opt := range opts {
			if o, ok := opt.({{.Value}}Machine.Option); ok {
				{{.Value}}Opts = append({{.Value}}Opts, o)
			} else {
				allMatch = false
				break
			}
		}

		if allMatch && len({{.Value}}Opts) > 0 {
			return New{{.Name}}Compiler({{.Value}}Opts...)
		}
	}
	{{end}}

	return nil, fmt.Errorf("unable to determine compiler type from provided options")
}

{{range .Types}}
// New{{.Name}}Compiler creates a new {{.Name}} compiler using the functional options pattern.
// See the {{.Value}}Machine package for available options.
func New{{.Name}}Compiler(opts ...{{.Value}}Machine.Option) (script.Compiler, error) {
	compiler, err := {{.Value}}Machine.NewCompiler(opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to create {{.Name}} compiler: %w", err)
	}
	return compiler, nil
}
{{end}}