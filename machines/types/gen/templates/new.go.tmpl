//go:generate go run ./types/gen/typeGen.go
// Code generated by go generate; DO NOT EDIT.

package machines

import (
	"fmt"
	"log/slog"

	"github.com/robbyt/go-polyscript/engine"
	"github.com/robbyt/go-polyscript/execution/data"
	"github.com/robbyt/go-polyscript/execution/script"
{{- range .Types}}
	{{.Value}}Machine "github.com/robbyt/go-polyscript/machines/{{.Value}}"
{{- end}}
	
	machineTypes "github.com/robbyt/go-polyscript/machines/types"
)

// NewEvaluator creates a new VM with the given CPU type and globals
// This will load a script from a ExecutableUnit object into the VM, and can be run immediately.
func NewEvaluator(handler slog.Handler, ver *script.ExecutableUnit, dataProvider data.InputDataProvider) (engine.Evaluator, error) {
	if ver == nil {
		return nil, fmt.Errorf("version is nil")
	}

	switch ver.GetMachineType() {
	{{- range .Types}}
	case machineTypes.{{.Name}}:
		// {{.Description}}
		return {{.Value}}Machine.NewBytecodeEvaluator(handler, dataProvider), nil
	{{- end}}
	default:
		return nil, fmt.Errorf("%w: %s", machineTypes.ErrInvalidMachineType, ver.GetMachineType())
	}
}

// NewCompiler creates a compiler for the specified machine type with given globals
func NewCompiler(handler slog.Handler, machineType machineTypes.Type, compilerOptions any) (script.Compiler, error) {
    switch machineType {
    {{- range .Types}}
    case machineTypes.{{.Name}}:
        // {{.Description}}
        {{.Value}}Options, ok := compilerOptions.({{.Value}}Machine.CompilerOptions)
        if !ok {
            return nil, fmt.Errorf("invalid compiler options for {{.Name}} machine, got %T", compilerOptions)
        }
        return {{.Value}}Machine.NewCompiler(handler, {{.Value}}Options), nil
    {{- end}}
    default:
        return nil, fmt.Errorf("unsupported machine type: %s", machineType)
    }
}