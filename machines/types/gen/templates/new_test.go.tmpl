// Code generated by go generate; DO NOT EDIT.

package machines

import (
	"log/slog"
	"os"
	"testing"

	"github.com/robbyt/go-polyscript/execution/script"
	machineTypes "github.com/robbyt/go-polyscript/machines/types"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestNewEvaluator(t *testing.T) {
	tests := []struct {
		name          string
		machineType   machineTypes.Type
		expectError   bool
		expectedError error
	}{
{{- range .Types}}
		{
			name:          "{{.Name}} machine type",
			machineType:   machineTypes.{{.Name}},
			expectError:   false,
			expectedError: nil,
		},
{{- end}}
		{
			name:          "Unsupported machine type",
			machineType:   "unsupported",
			expectError:   true,
			expectedError: machineTypes.ErrInvalidMachineType,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var ver *script.ExecutableUnit
			if tt.machineType != "" {
				mockContent := new(mockExecutableContent)
				mockContent.On("GetMachineType").Return(tt.machineType)
				ver = &script.ExecutableUnit{
					Content: mockContent,
				}
			}

						handler := slog.NewTextHandler(os.Stdout, nil)
				evaluator, err := NewEvaluator(handler, ver)

			if tt.expectError {
				require.Error(t, err)
				if tt.expectedError != nil {
					require.ErrorIs(t, err, tt.expectedError)
				}
				require.Nil(t, evaluator)
			} else {
				require.NoError(t, err)
				require.NotNil(t, evaluator)
			}
		})
	}
}

type mockExecutableContent struct {
	mock.Mock
}

func (m *mockExecutableContent) GetMachineType() machineTypes.Type {
	args := m.Called()
	return args.Get(0).(machineTypes.Type)
}

func (m *mockExecutableContent) GetSource() string {
	args := m.Called()
	return args.String(0)
}

func (m *mockExecutableContent) GetByteCode() any {
	args := m.Called()
	return args.Get(0)
}
