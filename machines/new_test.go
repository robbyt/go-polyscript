// Code generated by go generate; DO NOT EDIT.

package machines

import (
	"log/slog"
	"os"
	"testing"

	"github.com/robbyt/go-polyscript/execution/data"
	"github.com/robbyt/go-polyscript/execution/script"
	extismMachine "github.com/robbyt/go-polyscript/machines/extism"
	risorMachine "github.com/robbyt/go-polyscript/machines/risor"
	starlarkMachine "github.com/robbyt/go-polyscript/machines/starlark"
	machineTypes "github.com/robbyt/go-polyscript/machines/types"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestNewEvaluator(t *testing.T) {
	tests := []struct {
		name          string
		machineType   machineTypes.Type
		expectError   bool
		expectedError error
	}{
		{
			name:          "Risor machine type",
			machineType:   machineTypes.Risor,
			expectError:   false,
			expectedError: nil,
		},
		{
			name:          "Starlark machine type",
			machineType:   machineTypes.Starlark,
			expectError:   false,
			expectedError: nil,
		},
		{
			name:          "Extism machine type",
			machineType:   machineTypes.Extism,
			expectError:   false,
			expectedError: nil,
		},
		{
			name:          "Unsupported machine type",
			machineType:   "unsupported",
			expectError:   true,
			expectedError: machineTypes.ErrInvalidMachineType,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var ver *script.ExecutableUnit
			if tt.machineType != "" {
				mockContent := new(mockExecutableContent)
				mockContent.On("GetMachineType").Return(tt.machineType)
				ver = &script.ExecutableUnit{
					Content:      mockContent,
					DataProvider: data.NewContextProvider("test_key"),
				}
			}

			handler := slog.NewTextHandler(os.Stdout, nil)
			evaluator, err := NewEvaluator(handler, ver)

			if tt.expectError {
				require.Error(t, err)
				if tt.expectedError != nil {
					require.ErrorIs(t, err, tt.expectedError)
				}
				require.Nil(t, evaluator)
			} else {
				require.NoError(t, err)
				require.NotNil(t, evaluator)
			}
		})
	}
}

func TestNewRisorCompiler(t *testing.T) {
	t.Run("success", func(t *testing.T) {
		compiler, err := NewRisorCompiler(risorMachine.WithLogHandler(slog.NewTextHandler(os.Stdout, nil)))
		require.NoError(t, err)
		require.NotNil(t, compiler)
	})
}

func TestNewStarlarkCompiler(t *testing.T) {
	t.Run("success", func(t *testing.T) {
		compiler, err := NewStarlarkCompiler(starlarkMachine.WithLogHandler(slog.NewTextHandler(os.Stdout, nil)))
		require.NoError(t, err)
		require.NotNil(t, compiler)
	})
}

func TestNewExtismCompiler(t *testing.T) {
	t.Run("success", func(t *testing.T) {
		compiler, err := NewExtismCompiler(extismMachine.WithLogHandler(slog.NewTextHandler(os.Stdout, nil)))
		require.NoError(t, err)
		require.NotNil(t, compiler)
	})
}

type mockExecutableContent struct {
	mock.Mock
}

func (m *mockExecutableContent) GetMachineType() machineTypes.Type {
	args := m.Called()
	return args.Get(0).(machineTypes.Type)
}

func (m *mockExecutableContent) GetSource() string {
	args := m.Called()
	return args.String(0)
}

func (m *mockExecutableContent) GetByteCode() any {
	args := m.Called()
	return args.Get(0)
}
